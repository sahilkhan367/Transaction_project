#include <HardwareSerial.h>
#include <WiFi.h>
#include <WebServer.h>
#include <WiFiClientSecure.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <Preferences.h>
#include <DNSServer.h>
#include <Ticker.h>
#include "time.h"
#include <map>  // for storing tag timestamps
#include "base64.h"



// ----Things to change before installation-----
String deviceID = "1";
String ap_ssid_str = "ESP_AccessHub";
const char* ap_ssid = ap_ssid_str.c_str();
const char* ap_password = "12345678";

const char* BASE_URL = "https://iot.erpnoveloffice.in";
const char* DOCTYPE  = "Transaction_health";

const char* API_KEY    = "08d841c15a31507";
const char* API_SECRET = "7309d7204d9de02";

Ticker ledTimers[40];  // one timer per possible GPIO


const int AP_CHANNEL = 1;
const int AP_MAX_CONNECTION = 4;




const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 19800;
const int daylightOffset_sec = 0;


bool connectedToWiFi = false;

TaskHandle_t relayTaskHandle = NULL;
int relayDuration = 0;   // store latest duration
unsigned long relayStart = 0;

Preferences preferences;
WebServer server(80);
DNSServer dnsServer;
WiFiClientSecure ssl;


const char* serverUrl = "https://accesshub.novelinfra.com/api/submit";


#define BUFFER_SIZE 14
#define DATA_TAG_SIZE 8

#define RX1 3 //violet
#define TX1 1 //yello

#define RX2 16 //violet
#define TX2 17 //yellow


#define GREEN_1 4
#define RED_1 0

#define GREEN_2 2
#define RED_2 5


#define RELAY 13   // change to your GPIO pin

#define WIFI_LED 21
#define BUZZER_1 18
#define BUZZER_2 15


HardwareSerial ssrfid1(0);  // UART0 (use UART2 if USB serial conflicts)
HardwareSerial ssrfid2(2);  // UART0 (use UART2 if USB serial conflicts)

uint8_t buffer[BUFFER_SIZE];





const char* CONFIG_HTML = R"rawliteral(
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WiFi Setup</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .container {
            background: #fff;
            color: #000;
            border-radius: 8px;
            padding: 30px;
            width: 100%;
            max-width: 320px;
            text-align: center;
        }
        
        h1 {
            margin-bottom: 25px;
            font-size: 18px;
            font-weight: 600;
        }
        
        .form-group {
            margin-bottom: 20px;
            text-align: left;
        }
        
        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            font-size: 13px;
        }
        
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        
        input[type="text"]:focus, input[type="password"]:focus {
            outline: none;
            border-color: #000;
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            background: #000;
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .btn:hover {
            background: #333;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 6px;
            font-size: 12px;
            display: none;
        }
        
        .status.success {
            background: #e8f5e8;
            color: #2d5a2d;
            border: 1px solid #c3e6c3;
        }
        
        .status.error {
            background: #ffe8e8;
            color: #5a2d2d;
            border: 1px solid #e6c3c3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>WiFi Setup</h1>
        
        <form id="wifiForm">
        <div class="status success" style="display:block; background:#e8f5e8; color:#2d5a2d; border:1px solid #c3e6c3;">Connected to: <strong>{{CURRENT_SSID}}</strong></div>
            <div class="form-group">
                <label for="ssid">WiFi Name</label>
                <input type="text" id="ssid" name="ssid" placeholder="Enter WiFi name" required>
            </div>
            
            <div class="form-group">
                <label for="password">WiFi Password</label>
                <input type="password" id="password" name="password" placeholder="Enter WiFi password" required>
            </div>
            
            <button type="submit" class="btn">Connect</button>
            <br>
            <br>
            <button class="btn reset" onclick="resetDevice()">Reset Device</button>
            <br>
            <br>
            <button class="btn" onclick="location.href='/espconfig'">Device Config</button>
        </form>

        
        <div class="status" id="status"></div>
    </div>

    <script>
        document.getElementById('wifiForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const ssid = document.getElementById('ssid').value;
            const password = document.getElementById('password').value;
            const status = document.getElementById('status');
            
            if (!ssid || !password) {
                showStatus('Please fill in all fields', 'error');
                return;
            }
            
            fetch('/configure', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: `ssid=${encodeURIComponent(ssid)}&password=${encodeURIComponent(password)}`
            })
            .then(response => response.text())
            .then(data => {
                if (data.includes('success')) {
                    showStatus('WiFi configured successfully!', 'success');
                } else {
                    showStatus('Failed to configure WiFi', 'error');
                }
            })
            .catch(error => {
                showStatus('Connection error', 'error');
            });
        });
        
        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
        }
        function resetDevice() {
        fetch('/reset')
        .then(() => showStatus('Device restarting...', 'success'))
        .catch(() => showStatus('Reset failed!', 'error'));
        } 
    </script>
</body>
</html>
)rawliteral";



const char* ESP_CONFIG_HTML = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
<title>ESP Configuration</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>

body {
    font-family: Arial, sans-serif;
    background: #111;
    color: #fff;
    margin: 0;
    padding: 0;
}

.container {
    background: #fff;
    color: #000;
    width: 90%;
    max-width: 360px;
    padding: 25px;
    margin: 40px auto;
    border-radius: 14px;
    box-shadow: 0 0 12px rgba(255,255,255,0.15);
    text-align: center;
}

h2 {
    margin-bottom: 10px;
    font-size: 22px;
}

.info-box {
    background: #f0f0f0;
    padding: 10px;
    margin-bottom: 20px;
    border-radius: 8px;
    font-size: 14px;
    text-align: left;
}

label {
    display: block;
    margin-top: 15px;
    font-size: 14px;
    font-weight: 600;
    text-align: left;
}

input {
    width: 100%;
    padding: 12px;
    margin-top: 6px;
    border-radius: 6px;
    border: 1px solid #ccc;
    font-size: 14px;
}

.btn {
    width: 100%;
    padding: 12px;
    margin-top: 18px;
    background: #000;
    color: #fff;
    border: none;
    border-radius: 6px;
    font-size: 15px;
    cursor: pointer;
}

.btn:hover {
    background: #333;
}

.reset-btn {
    background: #d40000;
}

.reset-btn:hover {
    background: #a00000;
}

.back-btn {
    background: #444;
    margin-top: 10px;
}

.back-btn:hover {
    background: #222;
}

#msg {
    margin-top: 15px;
    font-size: 14px;
    font-weight: bold;
}

</style>
</head>
<body>

<div class="container">

    <h2>Device Configuration</h2>

    <div class="info-box">
        <strong>Current Device ID:</strong> {{DEVICE_ID}} <br>
        <strong>Current AP SSID:</strong> {{AP_SSID}}
    </div>

    <form id="espForm">
        <label>Device ID</label>
        <input type="text" id="devID" value="{{DEVICE_ID}}">

        <label>AP SSID</label>
        <input type="text" id="apSSID" value="{{AP_SSID}}">

        <button type="submit" class="btn">Save</button>

        <button type="button" class="btn reset-btn" onclick="resetDevice()">
            Reset Device
        </button>

        <!-- â­ BACK BUTTON ADDED HERE â­ -->
        <button type="button" class="btn back-btn" onclick="window.location.href='/'">
            Back
        </button>

    </form>

    <p id="msg"></p>

</div>

<script>
document.getElementById('espForm').addEventListener('submit', function(e){
    e.preventDefault();

    let id = document.getElementById('devID').value;
    let ssid = document.getElementById('apSSID').value;

    fetch('/saveesp', {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: 'id=' + id + '&ssid=' + ssid
    })
    .then(r => r.text())
    .then(t => document.getElementById('msg').innerHTML = t);
});

function resetDevice() {
    fetch('/reset')
    .then(() => document.getElementById('msg').innerHTML = "Device restarting...")
    .catch(() => document.getElementById('msg').innerHTML = "Reset failed!");
}
</script>

</body>
</html>
)rawliteral";


void setupWiFi() {
  preferences.begin("wifi", false);
  String saved_ssid = preferences.getString("ssid", "");
  String saved_pass = preferences.getString("pass", "");

  WiFi.mode(WIFI_AP_STA);

  // ------ Start Access Point ------
  IPAddress local_IP(10,10,10,1);
  IPAddress gateway(10,10,10,1);
  IPAddress subnet(255,255,255,0);

  WiFi.softAPConfig(local_IP, gateway, subnet);
  WiFi.softAP(ap_ssid, ap_password, AP_CHANNEL, false, AP_MAX_CONNECTION);

  Serial.print("ðŸ“¡ AP active @ ");
  Serial.println(WiFi.softAPIP());

  // ------ Connect to previous WiFi network ------
  if (saved_ssid.length() > 0) {
    Serial.println("ðŸ“¶ Trying stored WiFi: " + saved_ssid);

    WiFi.begin(saved_ssid.c_str(), saved_pass.c_str());
    unsigned long start = millis();

    while (WiFi.status() != WL_CONNECTED && millis() - start < 15000) {
      Serial.print(".");
      delay(500);
    }

    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\nâœ… Connected!");
      Serial.println(WiFi.localIP());
      connectedToWiFi = true;
    } 
    else {
      Serial.println("\nâŒ Failed to connect to WiFi.");
      connectedToWiFi = false;
    }
  } 
  else {
    Serial.println("âš ï¸ No saved WiFi credentials.");
  }

  preferences.end();
}


bool getDateTime(String &dateStr, String &timeStr) {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    Serial.println("Failed to obtain time");
    return false;
  }

  char dateBuffer[11]; // YYYY-MM-DD
  char timeBuffer[9];  // HH:MM:SS

  strftime(dateBuffer, sizeof(dateBuffer), "%Y-%m-%d", &timeinfo);
  strftime(timeBuffer, sizeof(timeBuffer), "%H:%M:%S", &timeinfo);

  dateStr = String(dateBuffer);
  timeStr = String(timeBuffer);

  return true;
}



String getUptimeReadable() {
  unsigned long seconds = millis() / 1000;

  unsigned long minutes = seconds / 60;
  unsigned long hours   = minutes / 60;

  seconds %= 60;
  minutes %= 60;

  if (hours > 0) {
    return String(hours) + " hour" + (hours > 1 ? "s " : " ") +
           String(minutes) + " min";
  } else if (minutes > 0) {
    return String(minutes) + " min";
  } else {
    return String(seconds) + " sec";
  }
}



void createTransactionHealthDoc() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi not connected");
    return;
  }

  String dateStr, timeStr;
  if (!getDateTime(dateStr, timeStr)) return;

  String uptimeStr = getUptimeReadable();

  HTTPClient http;
  String url = String(BASE_URL) + "/api/resource/" + DOCTYPE;

  http.begin(url);
  http.addHeader("Content-Type", "application/json");
  http.addHeader(
    "Authorization",
    "token " + String(API_KEY) + ":" + String(API_SECRET)
  );

  String payload = "{";
  payload += "\"doctype\":\"Transaction_health\",";
  payload += "\"id\":\"" + deviceID + "\",";
  payload += "\"status\":\"Active\",";
  payload += "\"date\":\"" + dateStr + "\",";
  payload += "\"time\":\"" + timeStr + "\",";
  payload += "\"uptime\":\"" + uptimeStr + "\"";
  payload += "}";

  int httpResponseCode = http.POST(payload);

  Serial.print("HTTP Code: ");
  Serial.println(httpResponseCode);
  Serial.println(http.getString());

  http.end();
}





void handleRoot() {
  String html(CONFIG_HTML);   // Convert from const char* â†’ editable String
  String currentSSID = WiFi.SSID();

  if (currentSSID == "") {
    currentSSID = "Not connected";
  }

  html.replace("{{CURRENT_SSID}}", currentSSID);  // Replace placeholder
  server.send(200, "text/html", html);
}


void handleConfigure() {
  if (server.hasArg("ssid") && server.hasArg("password")) {
    String ssid = server.arg("ssid");
    String password = server.arg("password");

    if (ssid == "" || password == "") {
      server.send(400, "text/plain", "Missing credentials");
      return;
    }

    WiFi.mode(WIFI_AP_STA);
    WiFi.begin(ssid.c_str(), password.c_str());

    bool connected = false;
    for (int i = 0; i < 15; i++) {
      if (WiFi.status() == WL_CONNECTED) {
        connected = true;
        digitalWrite(WIFI_LED, LOW);   // LED OFF when connected
        break;
      }
      delay(500);
    }

    if (connected) {
      preferences.putString("ssid", ssid);
      preferences.putString("pass", password);
      connectedToWiFi = true;
      server.send(200, "text/plain", "success");
    } else {
      connectedToWiFi = false;
      server.send(400, "text/plain", "Failed to connect");
    }
  } else {
    server.send(400, "text/plain", "Missing credentials");
  }
}

void handleNotFound() {
  server.sendHeader("Location", "/", true);
  server.send(302, "text/plain", "");
}







void setup() {
  Serial.begin(9600);
  delay(200);

  // -------- LOAD ESP CONFIG (Device ID + AP SSID) --------
  Preferences pref;
  pref.begin("espconfig", true);   // read-only
  deviceID    = pref.getString("deviceID", deviceID);
  ap_ssid_str = pref.getString("apssid", ap_ssid_str);
  pref.end();

  ap_ssid = ap_ssid_str.c_str();   // update const char*

  // -------- WIFI & ACCESS POINT --------
  ssl.setInsecure();
  setupWiFi();  // loads WiFi STA mode + launches AP

  // -------- GPIO SETUP --------
  pinMode(WIFI_LED, OUTPUT);
  pinMode(RED_1, OUTPUT);
  pinMode(GREEN_1, OUTPUT);
  pinMode(RED_2, OUTPUT);
  pinMode(GREEN_2, OUTPUT);
  pinMode(RELAY, OUTPUT);
  pinMode(BUZZER_1, OUTPUT);
  pinMode(BUZZER_2, OUTPUT);

  digitalWrite(WIFI_LED, HIGH);
  digitalWrite(RELAY, HIGH); // Relay OFF
  digitalWrite(RED_1, LOW);
  digitalWrite(GREEN_1, LOW);
  digitalWrite(RED_2, LOW);
  digitalWrite(GREEN_2, LOW);
  digitalWrite(BUZZER_1, LOW);
  digitalWrite(BUZZER_2, LOW);

  // -------- DNS SERVER (Captive Portal) --------
  dnsServer.start(53, "*", WiFi.softAPIP());

  // ----------- HTTP ROUTES (IMPORTANT: BEFORE server.begin()) -----------

  // Main WiFi config page
  server.on("/", HTTP_GET, handleRoot);

  // Save WiFi credentials
  server.on("/configure", HTTP_POST, handleConfigure);

  // ESP device config page
  server.on("/espconfig", HTTP_GET, []() {
    String page(ESP_CONFIG_HTML);

    page.replace("{{DEVICE_ID}}", deviceID);
    page.replace("{{AP_SSID}}", ap_ssid_str);

    server.send(200, "text/html", page);
  });

  // Save ESP deviceID + AP SSID
  server.on("/saveesp", HTTP_POST, []() {
    if (server.hasArg("id") && server.hasArg("ssid")) {

      String newID   = server.arg("id");
      String newSSID = server.arg("ssid");

      Preferences p;
      p.begin("espconfig", false);
      p.putString("deviceID", newID);
      p.putString("apssid", newSSID);
      p.end();

      deviceID = newID;
      ap_ssid_str = newSSID;
      ap_ssid = ap_ssid_str.c_str();

      server.send(200, "text/plain", "Saved! Please restart device.");
    } 
    else {
      server.send(400, "text/plain", "Missing data");
    }
  });

  // Reset device
  server.on("/reset", HTTP_GET, []() {
    server.send(200, "text/plain", "Restarting...");
    delay(500);
    ESP.restart();
  });

  // Fallback
  server.onNotFound(handleNotFound);

  // -------- START WEB SERVER --------
  server.begin();


  // -------- RFID SETUP --------
  ssrfid1.begin(9600, SERIAL_8N1, RX1, TX1);
  ssrfid2.begin(9600, SERIAL_8N1, RX2, TX2);
  ssrfid1.setTimeout(50);
  ssrfid2.setTimeout(50);
  Serial.println("RFID Ready");

  // -------- START NTP --------
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  Serial.println("â° NTP time synchronized");
}

void checkWiFiStatus() {
  if (WiFi.status() == WL_CONNECTED) {
    digitalWrite(WIFI_LED, LOW);
  } else {
    digitalWrite(WIFI_LED, HIGH);
  }
}



void checkWeeklyReset() {
  struct tm timeinfo;

  // If time isn't available yet
  if (!getLocalTime(&timeinfo)) {
    static unsigned long lastPrint = 0;
    if (millis() - lastPrint > 10000) {  // print every 10 sec max
      Serial.println("âš ï¸ Failed to get time (NTP not synced yet)");
      lastPrint = millis();
    }
    return;
  }

  int weekday = timeinfo.tm_wday;   // 0 = Sunday
  int hour = timeinfo.tm_hour;
  int minute = timeinfo.tm_min;
  int second = timeinfo.tm_sec;

  // Reset only on Sunday at 5:00:00 AM
  if (weekday == 0 && hour == 5 && minute == 0 && second == 0) {
    Serial.println("ðŸ•” Weekly auto-reset: Sunday 5:00 AM reached!");
    delay(1000);
    Serial.println("reset triggered!");
    ESP.restart();
  }
}


unsigned long lastTag1 = 0;
unsigned long lastTag2 = 0;
unsigned long lastReadTime1 = 0;
unsigned long lastReadTime2 = 0;


unsigned long lastRunTime = 0;
const unsigned long interval = 3600000; // 1 hour (60*60*1000)


void loop() {
  dnsServer.processNextRequest();
  server.handleClient();
  checkWiFiStatus();
  checkWeeklyReset();
  unsigned long currentTime = millis();

  if (lastRunTime == 0 || currentTime - lastRunTime >= interval) {
    lastRunTime = currentTime;
    createTransactionHealthDoc();  // runs immediately + every 1 hour
  }

  // Reader 1
  if (ssrfid1.available() >= BUFFER_SIZE) {
    ssrfid1.readBytes(buffer, BUFFER_SIZE);
    while (ssrfid1.available()) ssrfid1.read();
    unsigned long tag = extract_tag();
    String tagStr = String(tag);

    if (tag == 0 || tagStr.length() < 6 || tagStr.length() > 9) return;
    if (tag == lastTag1 && millis() - lastReadTime1 < 3000) return;

    lastTag1 = tag;
    lastReadTime1 = millis();
    Serial.print("Card ID1: ");
    Serial.println(tag);
    Serial.printf("Heap: %u bytes\n", ESP.getFreeHeap());
    String result = callAPI(deviceID.c_str(), String(tag).c_str(), "IN");
    delay(10); 
    if (result.indexOf("success") != -1) {
      turnOnRelay(5000);
      Serial.println("âœ… success");
      blinkLED(GREEN_1, 1000);
      blinkLED(BUZZER_1, 500);
    }
    else if (result.indexOf("error") != -1) {
      Serial.println("âŒ error");
      blinkLED(RED_1, 1000);
    }
  }

  // Reader 2
  if (ssrfid2.available() >= BUFFER_SIZE) {
    ssrfid2.readBytes(buffer, BUFFER_SIZE);
    while (ssrfid2.available()) ssrfid2.read();
    unsigned long tag = extract_tag();
    String tagStr = String(tag);

    if (tag == 0 || tagStr.length() < 6 || tagStr.length() > 9) return;
    if (tag == lastTag2 && millis() - lastReadTime2 < 3000) return;

    lastTag2 = tag;
    lastReadTime2 = millis();
    Serial.print("Card ID2: ");
    Serial.println(tag);
    Serial.printf("Heap: %u bytes\n", ESP.getFreeHeap());
    String result = callAPI(deviceID.c_str(), String(tag).c_str(), "OUT");
    delay(10); 
    if (result.indexOf("success") != -1) {
      turnOnRelay(5000);
      Serial.println("âœ… success");
      blinkLED(GREEN_2, 1000);
      blinkLED(BUZZER_2, 500);
    }
    else if (result.indexOf("error") != -1) {
      Serial.println("âŒ error");
      blinkLED(RED_2, 1000);
    }
  }
yield(); // prevent WDT lock
delay(10);
}



unsigned long extract_tag() {
  uint8_t *msg_data_tag = buffer + 3;
  return hexstr_to_value((char*)msg_data_tag, DATA_TAG_SIZE);
}

unsigned long hexstr_to_value(char *str, unsigned int length) {
  char temp[9];
  memcpy(temp, str, length);
  temp[length] = '\0';
  return strtoul(temp, NULL, 16);
}





String callAPI(const char* id, const char* rfid, const char* direction) {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi not connected!");
  }

  HTTPClient http;
  http.begin(serverUrl);
  http.addHeader("Content-Type", "application/json");

  StaticJsonDocument<200> doc;
  doc["ID"] = id;
  doc["RFID"] = rfid;
  doc["IN/OUT"] = direction;

  String requestBody;
  serializeJson(doc, requestBody);

  Serial.println("Sending JSON: " + requestBody);

  int httpCode = http.POST(requestBody);
  String response = http.getString();

  Serial.printf("Response code: %d\n", httpCode);
  Serial.println("Response: " + response);

  http.end();
  return response;
}


void relayTask(void* parameter) {
  for (;;) {
    if (relayDuration > 0) {
      digitalWrite(RELAY, LOW);  // relay ON
      if (millis() - relayStart >= relayDuration) {
        digitalWrite(RELAY, HIGH); // relay OFF
        relayDuration = 0;            // reset
      }
    }
    vTaskDelay(100 / portTICK_PERIOD_MS); // check every 100ms
  }
}

// Function to turn on relay with resettable timer
void turnOnRelay(int durationMs) {
  relayDuration = durationMs;     // update latest duration
  relayStart = millis();          // reset timer start
  Serial.println("Relay ON, duration reset to " + String(durationMs) + "ms");

  // create task once if not running
  if (relayTaskHandle == NULL) {
    xTaskCreate(
      relayTask,
      "RelayTask",
      2000,
      NULL,
      1,
      &relayTaskHandle
    );
  }
}




void blinkLED(int pin, unsigned long duration) {
  digitalWrite(pin, HIGH);
  ledTimers[pin].once_ms(duration, [pin]() {
    digitalWrite(pin, LOW);
  });
}
